<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Stan Notes</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
</head>
<body>
<h1 id="resources">Resources</h1>
<ul>
<li><a href="https://people.bath.ac.uk/jjf23/stan/">STAN for linear mixed models</a> by Julian Faraway, especially the penicillin example</li>
<li><a href="https://link.springer.com/article/10.3758/s13428-016-0746-9">Bayesian inference with Stan: A tutorial on adding custom distributions</a> by J Annis, B Miller, T Palmeri</li>
<li><a href="https://github.com/kholsinger/mixed-models">stan_lmer vs hard-coded Stan</a></li>
<li><a href="https://mc-stan.org/rstan/articles/rstan.html">RStan: the R interface to Stan</a></li>
<li><a href="https://kevinstadler.github.io/blog/bayesian-ordinal-regression-with-random-effects-using-brms/">Multi-level ordinal regression models with brms</a></li>
<li><a href="https://cran.r-project.org/web/packages/rstanarm/vignettes/glmer.html">Estimating generalized (non-)linear models with group-specific terms with rstanarm</a></li>
</ul>
<h1 id="inner-workings-of-the-bayesian-proportional-odds-model">Inner Workings of the Bayesian Proportional Odds Model</h1>
<ul>
<li>From Nathan James: Automatic imposition of order constraint for intercepts
<ul>
<li>For our Bayesian model the intuition behind the intercept ordering is that we first estimate the probabilities of being in each of the n categories (combining observed data with the Dirichlet prior) and then apply the link function to the cumulative probabilities to calculate the intercepts. Because the cumulative probabilities are ordered and the link is monotonic, the intercepts are also ordered. Here’s a few lines of example R code that illustrate the process</li>
<li>estimated posterior prob. of membership in 7 categories (when X*beta=0)</li>
<li>est_probs &lt;- c(0.11, 0.27, 0.16, 0.14, 0.04, 0.13, 0.15)</li>
<li>estimated posterior cumulative probs</li>
<li>cum_probs &lt;- cumsum(est_probs)</li>
<li>apply logit link to cum_probs to estimate intercepts</li>
<li>est_intercepts &lt;- qlogis(cum_probs)</li>
</ul></li>
<li>FH question: Since in the limit with no ties at all the first intercept when betas are all zero or covariates are all at their mean perhaps, is first intercept is logit((n-1)/n) and the last is login(1/n), would U(logit(n-1)/n), logit(1/n)) be appropriate? This is for the model form P(Y &gt;= y). One complication in that way of thinking is if there are clustered observations the probability would perhaps not use n but would use the number of clusters (?).</li>
<li>I previously attempted to use some uniform priors for the intercepts without much success. I think there are a few problems with using U(logit((n-1)/n), logit(1/n)). First these are not necessarily bounds for the posterior <em>distributions</em> of the first and last intercept; these are values of the MLEs. Also, if you use an independent U(logit((n-1)/n), logit(1/n)) prior for each intercept, there is nothing in the form of the prior to enforce the ordering constraint. We can put an order constraint on using Stan but this is pretty inefficient (this is the same reason why using brms for ordinal regression is inefficient with many categories). Both of these lead to sampling issues since we have so little data to inform the location of the intercepts in the continuous case. Last, if we’re truly in a continuous data setting, we don’t know the value of n before collecting the data, so we wouldn’t be able define the limits of the uniform distribution. To me, using the observed data to define the prior (even in this somewhat limited way) is a red flag that we’re “double-dipping”. We should be able to define the prior without seeing any data. That’s what I’m trying to do with the Dirichlet process prior.</li>
<li>Ben Goodrich reply: Dirichlet process makes sense conceptually, although you can’t do it literally in Stan because it concentrates on a finite set. Some people have had some success with a giant but finite number of components in a Dirichlet. Also, this reminds me of some stuff that other people were doing to use a spline or similar function for the baseline hazard in survival models, which also has to be strictly increasing.</li>
<li>Nathan: Ben - I agree with you about implementing a ‘true’ Dirichlet process in Stan; I think it will be difficult using HMC even with a finite Dirichlet process so I may have to venture outside the Stan-verse. As you mentioned there are close ties to other semi-parametric models such as those used in survival analysis. Frank - Can you elaborate more on the conditioning on sample size? In many models we assume n is fixed rather than a parameter, but the value of n doesn’t play any part in defining the form or number of parameters. Shouldn’t we be able to make draws from the prior distribution without knowing the sample size? It seems that assuming knowledge about the number of outcome categories for a traditional ordinal regression is qualitatively different than assuming we know the number of distinct continuous outcome values, but I’m not sure I can explain why.</li>
<li>Frank: The comment about a prior needing to have a kind of universal meaning is very interesting.  The prior should capture the pre-data state of knowledge, and if we have knowledge that uses n (which we’re already conditioning on) but does not use the data in any other way, perhaps this is OK.</li>
<li>Nathan: In the binomial case with parameter theta, there are multiple ways of defining a noninformative prior, e.g. beta(1,1) is a noninformative prior for theta, the improper beta(0,0) is a noninformative prior for logit(theta) and beta(1/2, 1/2) is the transformation invariant Jeffreys’ noninformative prior. As Gelman et al. mention in their Bayes’ book, there is no clear choice for a vague prior because a density that is ‘flat’ for one parameterization is not for another. There is an analogous relationship between binomial data with a beta prior and multinomial data with a Dirichlet prior. In our case using a concentration parameter of 1 gives equal density to all vectors of category probabilities (when all covars are 0), using a concentration parameter of 0 gives an improper prior that is uniform for the log category probabilities and results in a proper posterior if there is at least 1 observation per category. To match the intercept/cutpoint MLEs, I think we need the concentration parameter that gives a uniform prior for the link function applied to the cumulative category probabilities, i.e. logit(sum(cat. prob)) or probit(sum(cat. prob)). My guess is that the 1/n heuristic and your empirical formula are getting somewhat close to this, but I will spend some time to work through the math. It seems like this may be a situation where because the posterior inference is sensitive to prior choice there is no a perfect solution. We can offer some recommendations for what seems to work.</li>
</ul>
<p>Ben Goodrich put a function <code>Pr</code> inside the Stan code. This is used just for checking that probabilities add up to one. You can use <code>rstan::expose_stan_functions('foo.stan')</code> to access those functions from R.</p>
<h2 id="existing-stan-approaches">Existing <code>Stan</code> Approaches</h2>
<ul>
<li>See <a href="ttps://mc-stan.org/docs/2_23/stan-users-guide/ordered-logistic-section.html">this</a></li>
<li>Nathan: The model they show is the Stan manual uses improper priors for the cutpoints with only the ‘ordered’ constraint in the parameter block to make sure they are increasing. The order constraint itself converts to an unconstrained space using a log difference transformation, i.e. delta_1 = alpha_1, delta_2 = log(alpha_2 - alpha_1), delta_3 = log(alpha_3 - alpha_2). If the prior on the constrained space is improper, then the unconstrained prior will also be improper so a proper posterior distribution is not guaranteed. Usually, if there is a reasonable amount of observed data for each category then you can get convergence, but if the amount of data for each category is low (e.g. continuous CPM case or traditional ordinal model with low or zero counts in one or more categories) there can be problems getting the model to converge.</li>
<li>Michael Betancourt has a good blog post that goes into more detail and also describes the alternative Dirichlet prior <a href="https://betanalpha.github.io/assets/case_studies/ordinal_regression.html">here</a></li>
<li>More from Nathan James 2020-10-25: Except for negating alpha, the new intercept prior options in blrm looks like the default brms ordinal model that I used for our 2018 JSM poster (see ‘Model’ section of https://ntjames.com/wp-content/uploads/2018/07/JSM18_poster.pdf) which is also similar to the ordered logistic/probit examples in the Stan Users guide (see sec 1.8 of https://mc-stan.org/docs/2_24/stan-users-guide-2_24.pdf). It seemed to work ok for moderate size data, but bogged down more &amp; more with a larger number of distinct values or when using non-symmetric links. Probably also worth pointing out that using an ordered vector with independent priors combines elements of the two approaches discussed around pg. 4 of the Bayes CPM manuscript. The ordering constraint is enforced using a transformation to an unconstrained space similar to Albert &amp; Chib (sec 10.6 of https://mc-stan.org/docs/2_24/reference-manual- 2_24.pdf). The joint prior on the untransformed scale is truncated to support over points that satisfy the ordering constraint (also mentioned in the Users guide above), similar to the approach used by McKinley et al. and Congdon</li>
</ul>
<h1 id="qr-decomposition-for-orthonormalization">QR Decomposition for Orthonormalization</h1>
<p>From Ben Goodrich</p>
<p>The last <span class="math inline">\(\beta\)</span> parameter is unchanged so its <span class="math inline">\(\beta\)</span> equals its <span class="math inline">\(\theta\)</span> parameter in the Stan program. This will sometimes create a warning message (e.g. when using <code>pairs()</code> that “beta[…] is duplicative”).</p>
<p>However, compiling an entire Stan program just to obtain a rescaled QR decomposition is overkill because the same can be accomplished with just R code. So, if you replace your stanQr() function with this function that does what your qr.stan program does:</p>
<pre><code>stanQr &lt;- function(X, center = TRUE) {
  p &lt;- ncol(X)
  N &lt;- nrow(X)
  if (center) X &lt;- scale(X, center = TRUE, scale = FALSE)
  QR &lt;- qr(X)
  Q &lt;- qr.Q(QR)
  R &lt;- qr.R(QR)
  sgns &lt;- sign(diag(R))
  Q_ast &lt;- sweep(Q, MARGIN = 2, STATS = sgns, FUN = `*`)
  R_ast &lt;- sweep(R, MARGIN = 1, STATS = sgns, FUN = `*`)
  corner &lt;- R_ast[p, p]
  R_ast_inverse &lt;- backsolve(R_ast, diag(p))
  Q_ast &lt;- Q_ast * corner
  R_ast &lt;- R_ast / corner
  R_ast_inverse &lt;- R_ast_inverse * corner
  return(list(Xqr = Q_ast, R = R_ast, R_inv = R_ast_inverse))
}</code></pre>
<p>Then you also get the necessary equivalence. Moreover, the bottom right element of w<span class="math inline">\(R and w\)</span>R_inv is 1.0 so the last coefficient is the same even though the design matrices are different.</p>
<p>All of the columns of X are different from all of the columns of Q_ast (which is what you are calling Xqr). They have to be; otherwise they wouldn’t be orthogonal. But the sequence of equalities still holds</p>
<p>eta = X * beta = (Q * R) * beta = (Q * corner * 1 / corner * R) * beta = (Q_ast * R_ast) * beta = Q_ast * (R_ast * beta) = Q_ast * theta</p>
<p>where theta = R_ast * beta. So, if you do the model in terms of Q_ast and get (the posterior distribution of) the K-vector theta. When you pre-multiply theta by the upper-triangular matrix R_ast^{-1}, since the lower-right corner of both R_ast and R_ast^{-1} is 1.0, beta[K] = 0 * theta[1] + 0 * theta[2] + … + 0 * theta[K - 1] + 1.0 * theta[K] = theta[K]. In other words, although you changed the design matrix, you left the K-th coefficient as is and changed the preceding K - 1 coefficients.</p>
<p>In the case of a continuous outcome and no link function, the same idea is used to get least-squares estimates</p>
<p>https://en.wikipedia.org/wiki/Numerical_methods_for_linear_least_squares#Orthogonal_decomposition_methods</p>
<p>where theta = Q’ * y and then you pre-multiply theta by R^{-1}. We just added the renormalization to make the lower-right element 1.0 so that it is easy to specify a prior on theta[K].</p>
<p>Q: Does this guarantee that the prior for the last beta does really get applied to the treatment effect and only the treatment effect?</p>
<p>A: Yes, if the priors on the elements of theta are independent, which is the way we have written it in the .stan programs and would seem to be the only sensible choice since the columns of Q_ast are orthogonal to each other.</p>
<p>Q: If I were to split the design matrices into two matrices (and for this case the 2nd matrix has one column), apply QR to the first and not the second, and combine into one log likelihood evaluation, would I get exactly the same results as the “corner QR” method?</p>
<p>Generally, no. In the example you gave earlier, if you split the third column of X out, then it remains highly correlated with the first two:</p>
<pre><code>w &lt;- stanQr(X[,1:2])
zapsmall(cor(cbind(w$Xqr, scale(X[,3], center = TRUE, scale = FALSE))))
          [,1]      [,2]      [,3]
[1,] 1.0000000 0.0000000 0.5685352
[2,] 0.0000000 1.0000000 0.5932746
[3,] 0.5685352 0.5932746 1.0000000</code></pre>
<p>In the case where the last variable is randomized, then the correlation would be close to zero, but it isn’t exactly the same as orthogonalizing.</p>
<h1 id="general-information-about-random-effects">General Information About Random Effects</h1>
<ul>
<li>From Jonathan Schildcrout: Omitting random effects from a model
<ul>
<li>This is not bias. The two models are estimating different parameters. For Binary data there are approximations that can be used to convert between the marginal (what LRM estimates) and conditional (what random effects estimate) parameters. See Zeger Liang and Albert 1988. Not sure if that works for general ordinal data.</li>
<li>The ZLA conversion is this</li>
<li>Sigma = 2.04</li>
<li>C = 16<em>sqrt(3)/(15</em>3.14)</li>
<li>Mult = 1 / sqrt(c^2 * Sigma^2 +1) = 0.76</li>
<li>beta.marg = Mult * beta.cond</li>
<li>You can think of the sd of the random effects as a coefficient for a standardized covariate that was not observed: <span class="math inline">\(Logit(p_{ij}) = x_{ij} \beta + b_i\)</span>, and <span class="math inline">\(b_i ~ N(0, \sigma^2)\)</span> which means <span class="math inline">\(Logit(p_{ij}) = x_{ij} \beta + \sigma * Z_i\)</span> , and <span class="math inline">\(Z_i ~ N(0, 1)\)</span></li>
</ul></li>
<li>Ben Goodrich: Why not use a prior that is n(0, <span class="math inline">\(\sigma_{\gamma}\)</span>)
<ul>
<li>The main thing is that usually (but unfortunately not always) the MCMC goes better if you utilize the stochastic representation of the normal distribution, which entails putting the unscaled random effects in the parameters block and scaling them by sigmag in the transformed parameters block to get the scaled random effects that go into the likelihood function. Then, the unscaled random effects get a standard normal prior, which implies before you see the data that the scaled random effects are distributed normal with mean zero and standard deviation sigmag. That tends to reduce the posterior dependence between sigmag and the (unscaled) random effects. In addition, there should be a proper prior on sigmag. I put it as exponential, but you would need to pass in the prior rate from R.</li>
</ul></li>
</ul>
<h1 id="mles-and-optimization-for-random-effects-models">MLEs and Optimization for Random Effects Models</h1>
<ul>
<li>From Ben Goodrich: Inconsistent results when using <code>rstan::optimizing</code>
<ul>
<li>Optimizing is not going to work well in hierarchical models that condition on the values of the random effects because (penalized) MLE is not a consistent estimator of (any of) the parameters as the number of clusters gets large. That is why Frequentists have to first integrate the random effects out of the likelihood before they can choose the fixed effects to maximize it. If you do MCMC, then the posterior means and medians should be much more stable than the modes. You can also try the vb() function, which implements variational Bayesian inference — essentially trying to find the closest multivariate normal distribution to posterior distribution in the unconstrained space — but that tends to not work well in general either.</li>
</ul></li>
</ul>
<h1 id="prediction-with-random-effects">Prediction With Random Effects</h1>
<ul>
<li>Ben Goodrich: Everything about the random effect stuff is easier from a Bayesian perspective, except for one thing: If you want to evaluate the model based on how it is expected to predict new patients (that by definition have not been observed yet), then you have to re-calculate the log-likelihood contributions in generated quantities after numerically integrating out the random effects like the Frequentists do. This is not so bad to code now that Stan has a one-dimensional numerical integration function, but it takes doing. See https://arxiv.org/abs/1802.04452</li>
</ul>
<p><a name="ar1"></a></p>
<h1 id="ar1-modeling">AR(1) Modeling</h1>
<ul>
<li><a href="https://discourse.mc-stan.org/t/migrated-from-google-group-ar-1-logistic-regression-funnel" class="uri">https://discourse.mc-stan.org/t/migrated-from-google-group-ar-1-logistic-regression-funnel</a></li>
<li><a href="https://discourse.mc-stan.org/t/improving-efficiency-when-modeling-autocorrelation" class="uri">https://discourse.mc-stan.org/t/improving-efficiency-when-modeling-autocorrelation</a></li>
<li><a href="https://discourse.mc-stan.org/t/dynamic-panel-data-models-with-stan" class="uri">https://discourse.mc-stan.org/t/dynamic-panel-data-models-with-stan</a></li>
<li><a href="https://github.com/jgabry/stancon2018helsinki_intro/tree/master/slides" class="uri">https://github.com/jgabry/stancon2018helsinki_intro/tree/master/slides</a></li>
<li><a href="https://github.com/jgabry/stancon2018helsinki_intro/blob/master/Pest_Control_Example.Rmd" class="uri">https://github.com/jgabry/stancon2018helsinki_intro/blob/master/Pest_Control_Example.Rmd</a></li>
<li><a href="https://mc-stan.org/docs/2_20/stan-users-guide/autoregressive-section.html" class="uri">https://mc-stan.org/docs/2_20/stan-users-guide/autoregressive-section.html</a></li>
<li><a href="https://www.mathworks.com/help/econ/simulate-stationary-arma-processes.html" class="uri">https://www.mathworks.com/help/econ/simulate-stationary-arma-processes.html</a> (kick starting the process with unconditional mean)</li>
<li><a href="https://www.math.utah.edu/~zhorvath/ar1.pdf" class="uri">https://www.math.utah.edu/~zhorvath/ar1.pdf</a> (recursive substitution p. 5)</li>
</ul>
<p>The equation in the last reference p. 5 allows specification of the random effect at time t without passing through all the previous random effects, so it accounts for unequally spaced and missing time points. It suggests this model:</p>
<ul>
<li>Let <span class="math inline">\(T\)</span> be the integer maximum observation time over all subjects</li>
<li>Suppose that observation times are <span class="math inline">\(t=1, \dots, T\)</span></li>
<li>Let <span class="math inline">\(\gamma_i\)</span> be a <span class="math inline">\(n(0, \sigma_\gamma\)</span>) random effect for the <span class="math inline">\(i\)</span>th subject.</li>
<li>Let <span class="math inline">\(\epsilon_{i,1}, ... \epsilon_{i,T}\)</span> be the within-subject white noise for the <span class="math inline">\(i\)</span>th subject that is <span class="math inline">\(n(0, \sigma_w)\)</span>, where <span class="math inline">\(T\)</span> is the maximum follow-up time (we may only use the first few of these for a given subject)</li>
<li><span class="math inline">\(\epsilon_{i,1} = \gamma_i\)</span> so the usual random effect as generated for a hierarchical (compound symmetric correlation pattern) repeated measures model is the starting white noise for a given subject</li>
<li>Then the random effect for subject <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span> is <span class="math inline">\(r_{i,t} = \rho^{t}\gamma_i + \rho^{t-1}\epsilon_{i,1} + \rho^{t-2}\epsilon_{i,2} + ... \epsilon_{i,T}\)</span></li>
<li>The random effects must all be defined regardless of which observations are actually observed, so we can re-write the model as using a matrix of random effects <span class="math inline">\(r_{i,1} = \gamma_i, r_{i,2} = \rho r_{i,1} + \epsilon_{i,2}, r_{i,3} = \rho r_{i, 2} + \epsilon_{i,3}, ...\)</span>.</li>
</ul>
<p>Would this specification lead to sampling problems? Do <span class="math inline">\(\sigma_\gamma\)</span> and <span class="math inline">\(\sigma_w\)</span> compete too much?</p>
<p>Ben Goodrich re warnings about Pareto k diagnostics from <code>loo()</code>: The <code>loo()</code> function is trying to estimate what would happen if 1 patient were dropped from the analysis and predicted conditional on all the other patients. But its importance sampling has infinite variance when the Pareto k for the left-out observation is greater than 1 and has too high variance if the Pareto k is greater than 0.7. The Pareto k pertains to how much the posterior distribution would change if one observation were left out. In these models, if one person were left out the corresponding gamma and that patient’s column of eps_raw would revert to their prior distributions because there would no longer be any information in the data to update them with. Thus, this posterior distribution is too sensitive to the particular patients being conditioned on to estimate the expected log predictive density of future patients well.</p>
<p>To overcome this problem, we can do K-fold with K equal to the number of patients or redo the loo calculation to use a likelihood function that integrates the random effects out like in a Frequentist estimator, as described in that Psychometrica article I sent you the link to. But we can still use Stan to first obtain the posterior draws conditional on the random effects.</p>
<p><a name="ar1h"></a></p>
<p>FH question on homescedasticity of random effects: With random effect for subject <span class="math inline">\(i\)</span> at the first time <span class="math inline">\(t=1\)</span> having variance <span class="math inline">\(\sigma^2_\gamma\)</span>, we can use the recursive relationship <span class="math inline">\(V(X_t) = \rho^2 V(X_{t-1}) + \sigma^2_\epsilon\)</span> to get variances at other times, where <span class="math inline">\(\sigma^2_\epsilon\)</span> is the within-subject white noise variance. The variance of the random effect at time <span class="math inline">\(t=2\)</span> is <span class="math inline">\(\rho^2 \sigma^2_\gamma + \sigma^2_\epsilon\)</span> and equating the two successive variances results in <span class="math inline">\(\sigma_\epsilon = \sigma_\gamma \sqrt{1 - \rho^2}\)</span>. The same equation <span class="math inline">\(\times \rho^2\)</span> results from equating the variance at <span class="math inline">\(t=3\)</span> to the variance at <span class="math inline">\(t=2\)</span> and the same equation $<span class="math inline">\(\rho^4\)</span> results when comparing <span class="math inline">\(t=4\)</span> to <span class="math inline">\(t=3\)</span>. So it is reasonable to not make <span class="math inline">\(\sigma_\epsilon\)</span> a free parameter but instead to derive it from <span class="math inline">\(\sigma_\gamma\)</span> and <span class="math inline">\(\rho\)</span>? Would this make posterior sampling behave much better too? On the other hand, this homoscedasticity restriction may effectively limit the magnitude of correlation so perhaps the restriction should not be used.</p>
<p>The variances of <span class="math inline">\(X_t\)</span> for <span class="math inline">\(t=1,2,3,4\)</span> are: <span class="math inline">\(\sigma^2_\gamma\)</span>, <span class="math inline">\(\rho^2 \sigma^2_\gamma + \sigma^2_\epsilon\)</span>, <span class="math inline">\(\rho^4 \sigma^2_\gamma + (1 + \rho^2) \sigma^2_\epsilon\)</span>, <span class="math inline">\(\rho^6 \sigma^2_\gamma + (\rho^4 + \rho^2 + 1) \sigma^2_\epsilon)\)</span>.</p>
<p><a name='serialto'></a></p>
<h1 id="trade-offs-for-various-longitudinal-model-formulations">Trade-offs for Various Longitudinal Model Formulations</h1>
<h2 id="lee-and-daniels-marginal-po-state-transition-model">Lee and Daniels Marginal PO State Transition Model</h2>
<ul>
<li>Simple interpretation, with a traditional intention-to-treat treatment effect parameter (odds ratio)</li>
<li>Doesn’t require random effects to handle within-subject correlation</li>
<li>Harder to analyze non-uniform time spacing</li>
<li>Likelihood function is not expressible analytically, which adds to computational burden</li>
</ul>
<h2 id="ar1">AR(1)</h2>
<ul>
<li>Simple interpretation</li>
<li>Requires random effects</li>
<li>Possible posterior sampling problems</li>
<li>Hard to achieve high correlations on the raw Y scale, even when serial correlations on the linear predictor (logit) scale is very high. Must have high white noise variance <span class="math inline">\(\sigma_\epsilon\)</span> to get high correlation on Y within subject.</li>
</ul>
<h2 id="ordinary-random-effects-random-intercepts">Ordinary Random Effects (Random Intercepts)</h2>
<ul>
<li>Simple interpretation</li>
<li>Requires random effects</li>
<li>Assumes equal correlation within subject independent of time spacing</li>
</ul>
<h2 id="simple-serial-dependence-model-on-y-scale">Simple Serial Dependence Model on Y Scale</h2>
<ul>
<li>Simple likelihood</li>
<li>No random effects needed if one can assume that outcomes within subject are conditionally independent given previous outcomes</li>
<li>Must have a good portion of the outcome levels measured at baseline to start the process</li>
<li>Can handle arbitrary within-subject correlation patterns; this is probably the most general method</li>
<li>Not possible to have a single parameter for treatment (such as OR)</li>
<li>Can marginalize model predicted values to get <strong>covariate-specific</strong> treatment differences in absolute cumulative risk at a <strong>specific time</strong></li>
<li>On the last point, since Bayes invites us to <strong>not</strong> use parameter point estimates, it may be a good idea <strong>not</strong> to do all the multiplications to obtain the unconditional distribution of Y at a later time point. Instead, it probably works to use Bayesian posterior predictive distribution to simulate a very large number of subjects (large enough so that simulation error is negligible) from the already-sampled posterior draws of the model parameters, including the lag Y coefficients. One simulates the first post-baseline measurement of Y from the model, separately for treatment=B and treatment=A and for a given set of covariate values. Then one uses this simulated value of Y to simulate the next time period’s Y, uses this to simulate the next, and so on. From all the simulated datasets one estimates the posterior probability of a condition by computing the fraction of datasets for which the condition was true, separately by treatment.</li>
</ul>
<p><a name="ppo"></a></p>
<h1 id="partial-proportional-odds-model">Partial Proportional Odds Model</h1>
<p>The <a href="http://hbiostat.org/papers/feh/pet90par.pdf">PPO model</a> of Peterson and Harrell (1990) in its <em>unconstrained</em> form (Eq. (5) of the reference) has this specification for a single observation when <span class="math inline">\(Y=1, 2, ..., k\)</span> when <span class="math inline">\(j &gt; 1\)</span> (the paper uses a different coding, for <span class="math inline">\(Y=0, ..., k\)</span> so their <span class="math inline">\(k\)</span> is our <span class="math inline">\(k-1\)</span>)):</p>
<p><span class="math display">\[P(Y \geq j | X) = \text{expit}(\alpha_{j-1} + X\beta + [j &gt; 2] Z\tau_{j-2}) = \text{expit}(c_{j})\]</span></p>
<ul>
<li><span class="math inline">\(c_{1}\)</span>: undefined and unused</li>
<li><span class="math inline">\(\alpha\)</span>: <span class="math inline">\(k-1\)</span> vector of overall intercepts</li>
<li><span class="math inline">\(\tau\)</span>: <span class="math inline">\(k-2 \times q\)</span> matrix of parameters</li>
</ul>
<p>For the entire dataset <span class="math inline">\(Z\)</span> is an <span class="math inline">\(n\times q\)</span> design matrix specifying the form of departures from proportional odds, and to honor the hierarchy principle for interactions must be a subset of the columns of <span class="math inline">\(X_{n, p}\)</span>. With regard to <span class="math inline">\(Z\)</span> the model is multinomial instead of ordinal, and so unlike the PO model there are issues with cell sizes in the <span class="math inline">\(Y\)</span> frequency distribution. The unconstrained PPO model is strictly for discrete ordinal <span class="math inline">\(Y\)</span> and there must be at least <span class="math inline">\(k=3\)</span> levels of <span class="math inline">\(Y\)</span>. The <span class="math inline">\(\alpha\)</span>s are the intercepts for <span class="math inline">\(Y \geq 2\)</span> (and thus their negatives are intercepts for <span class="math inline">\(Y=1\)</span>).</p>
<p>Likelihood components are as follows:</p>
<ul>
<li><span class="math inline">\(Y=1\)</span>: <span class="math inline">\(\text{expit}(- c_2)\)</span> (<span class="math inline">\(Z\)</span> ignored)</li>
<li><span class="math inline">\(Y=2, ..., k-1\)</span>: <span class="math inline">\(\text{expit}(c_Y) - \text{expit}(c_{Y+1})\)</span> (<span class="math inline">\(Z\)</span> ignored in first term when <span class="math inline">\(Y=2\)</span>)</li>
<li><span class="math inline">\(Y=k\)</span>: <span class="math inline">\(\text{expit}(c_k)\)</span> (<span class="math inline">\(Z\)</span> used)</li>
</ul>
<p>In <code>Stan</code> code <code>prmqrcppo.stan</code>, <span class="math inline">\(Z\)</span> is orthonormalized by the QR decomposition, and the PPO parameters on this new scale are <span class="math inline">\(\omega\)</span> instead of <span class="math inline">\(\tau\)</span> just as <span class="math inline">\(\theta\)</span> is substituted for <span class="math inline">\(\beta\)</span>. This code implements cluster (random) effects, so if there are no repeated observations per subject the user needs to specify a very small mean for the exponential prior for the variance of random effects (e.g., 0.001).</p>
<p>The <span class="math inline">\(p\)</span>-vector of normal prior standard deviations for <span class="math inline">\(\theta\)</span> is <code>sds</code> and a separate <span class="math inline">\(k-2 \times q\)</span> matrix of normal prior SDs for <span class="math inline">\(\omega\)</span> is given by <code>sdsppo</code>. If a binary treatment variable is present and one wants full control over its prior SD, be sure to put treatment as the last parameter for <span class="math inline">\(X\)</span>, and if treatment is allowed to violate the PO assumption also put treatment as the last parameter for <span class="math inline">\(Z\)</span>.</p>
<p>To some extent the constrained PPO model may be obtained by using very skeptical priors on the <span class="math inline">\(\omega\)</span> (transformed <span class="math inline">\(\tau\)</span>) parameters, e.g., standard deviations &lt; 1.0. This will lower the effective number of model parameters.</p>
<h2 id="constrained-partial-proportional-odds-model">Constrained Partial Proportional Odds Model</h2>
<p>This is Eq. (6) of Peterson &amp; Harrell (1990) and is akin to including interactions between covariates and <span class="math inline">\(\log(t)\)</span> in a Cox proportional hazards model. As discussed in <a href="https://arxiv.org/abs/2006.03914">Tutz and Berger</a> this is like having separate regression models for the mean and the variance.</p>
<p>Let <span class="math inline">\(f(y)\)</span> denote a continuous or discontinuous function of the response variable value <span class="math inline">\(y\)</span>. If <span class="math inline">\(Y\)</span> is continuous this will usually be a continuous function, and if <span class="math inline">\(Y\)</span> is discrete it may be linear in the integer category numbers or may be an indicator variable to allow one category of <span class="math inline">\(Y\)</span> to not operate in proportional odds for specific covariates <span class="math inline">\(Z\)</span>. If <span class="math inline">\(Y=1, 2, \ldots, k\)</span>, the model is <span class="math inline">\(P(Y \geq y) = \text{expit}(\alpha_{y-1} + X\beta + f(y)Z\tau)\)</span> One can see a great reduction in the number of non-PO parameters <span class="math inline">\(\tau\)</span> to estimate as <span class="math inline">\(\tau\)</span> is now a <span class="math inline">\(q\)</span>-vector instead of a <span class="math inline">\((k-2) \times q\)</span> matrix.</p>
<p>The likelihood components for <span class="math inline">\(Y=j^{th}\)</span> ordered distinct value of <span class="math inline">\(Y\)</span> are as follows:</p>
<ul>
<li><span class="math inline">\(y=1\)</span>: <span class="math inline">\(\text{expit}(-[\alpha_1 + X\beta + f(y_2)Z\tau])\)</span></li>
<li><span class="math inline">\(y=2, \ldots, k-1\)</span>: <span class="math inline">\(\text{expit}(\alpha_{j-1} + X\beta + f(y_j)Z\tau) - \text{expit}(\alpha_j + X\beta + f(y_{j+1})Z\tau)\)</span></li>
<li><span class="math inline">\(y=k\)</span>: <span class="math inline">\(\text{expit}(\alpha_{k-1} + X\beta + f(y_k)Z\tau)\)</span></li>
</ul>
<p>In the <code>blrm</code> function the <code>f</code> function is the parameter <code>cppo</code>, and to help along the MCMC poseterior sampling this function is automatically normalized to have mean 0 and SD 1 over the dataset (or user-provided <code>center</code> and <code>scale</code> parameters can be used). In order to do this the user must define <code>f</code> so that the last line of the function (the returned value) is e.g. <code>(value - center) / scale</code>. If <code>center</code> and <code>scale</code> are not arguments to <code>f</code>, these arguments will be added automically and computed from the observed mean and SD (but the last line that does the scaling must appear).</p>
<h1 id="censored-data">Censored Data</h1>
<p>Assume that all possible categories of Y are completely observed in at least one observation. This implies that if <span class="math inline">\(Y=1,\ldots,k\)</span> left censoring at <span class="math inline">\(a\)</span> is interval censored at <span class="math inline">\([1, a]\)</span> and right censoring at <span class="math inline">\(b\)</span> is interval censored at <span class="math inline">\([b, k]\)</span>. Consider an observation with Y interval censored in <span class="math inline">\([a,b]\)</span>. Then</p>
<ul>
<li>if <span class="math inline">\(a=1\)</span> and <span class="math inline">\(b=k\)</span> the observation is ignored</li>
<li>if <span class="math inline">\(a=b\)</span> the observation is completely observed and the regular likelihood components above are used</li>
<li>if <span class="math inline">\(b=k\)</span> (obs is right censored at <span class="math inline">\(a\)</span>), the likelihood is <span class="math inline">\(P(Y \geq a) = \text{expit}(alpha_{a-1} + X\beta)\)</span></li>
<li>if <span class="math inline">\(a=1\)</span> (obs is left censored at <span class="math inline">\(b\)</span>), the likelihood is <span class="math inline">\(P(Y \leq b) = 1 - P(Y &gt; b) = \text{expit}(-(\alpha_{b} + X\beta))\)</span></li>
<li>if <span class="math inline">\(b &gt; a\)</span> when <span class="math inline">\(a &gt; 1\)</span> and <span class="math inline">\(b &lt; k\)</span>, the likelihood is <span class="math inline">\(P(Y \in [a,b]) = P(Y \leq b) - P(Y &lt; a) = 1 - P(Y &gt; b) - (1 - P(Y \geq a)) = P(Y \geq a) - P(Y &gt; b) = \text{expit}(\alpha_{a-1} + X\beta) - \text{expit}(\alpha_{b} + X\beta)\)</span></li>
</ul>
<h2 id="censored-data-in-constrained-partial-po-model">Censored Data in Constrained Partial PO Model</h2>
<p>Likelihood components are as follows:</p>
<ul>
<li>if <span class="math inline">\(a=1\)</span> and <span class="math inline">\(b=k\)</span> the observation is ignored</li>
<li>if <span class="math inline">\(a=b\)</span> the observation is completely observed and the regular likelihood components are used</li>
<li>if <span class="math inline">\(b=k\)</span> (obs is right censored at <span class="math inline">\(a\)</span>), the likelihood is <span class="math inline">\(P(Y \geq a) = \text{expit}(\alpha_{a-1} + X\beta + f(a)Z\tau)\)</span></li>
<li>if <span class="math inline">\(a=1\)</span> (obs is left censored at <span class="math inline">\(b\)</span>), the likelihood is <span class="math inline">\(P(Y \leq b) = 1 - P(Y &gt; b) = \text{expit}(-(\alpha_{b} + X\beta + f(b+)Z\tau))\)</span></li>
<li>if <span class="math inline">\(b &gt; a\)</span> when <span class="math inline">\(a &gt; 1\)</span> and <span class="math inline">\(b &lt; k\)</span>, the likelihood is <span class="math inline">\(P(Y \in [a,b]) = P(Y \leq b) - P(Y &lt; a) = 1 - P(Y &gt; b) - (1 - P(Y \geq a)) = P(Y \geq a) - P(Y &gt; b) = \text{expit}(\alpha_{a-1} + X\beta + f(a)Z\tau) - \text{expit}(\alpha_{b} + X\beta + f(b+)Z\tau)\)</span></li>
</ul>
<p>Since <span class="math inline">\(Y\)</span> is coded internally as <span class="math inline">\(1, \ldots, k\)</span>, <span class="math inline">\(f(b+) = f(b+1)\)</span>.</p>
<h1 id="pertinent-stan-documentation">Pertinent Stan Documentation</h1>
<ul>
<li><a href="https://mc-stan.org/docs/2_23/stan-users-guide/basic-motivation.html">Basics</a></li>
<li><a href="https://mc-stan.org/docs/2_23/stan-users-guide/multi-indexing-chapter.html">Multi-indexes</a></li>
<li><a href="https://mc-stan.org/docs/2_23/functions-reference/mixed-operations.html">Mixed operations</a></li>
<li><a href="https://mc-stan.org/docs/2_23/stan-users-guide/log-sum-of-exponentials.html">log Sums</a></li>
<li><a href="https://mc-stan.org/docs/2_23/stan-users-guide/QR-reparameterization-section.html">Reparameterization</a></li>
<li><a href="https://mc-stan.org/docs/2_23/stan-users-guide/ordered-logistic-section.html">Ordered logisitic</a></li>
<li><a href="https://github.com/stan-dev/stan/issues/2377">Conditional parameters</a></li>
<li><a href="https://mc-stan.org/rstantools/articles">R package development with Stan</a></li>
</ul>
<h2 id="especially-relevant-functions">Especially Relevant Functions</h2>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Computes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>log1m_exp</td>
<td>log(1 - exp(x))</td>
</tr>
<tr class="even">
<td>log1p_exp</td>
<td>log(1 + exp(x))</td>
</tr>
<tr class="odd">
<td>log_diff_exp</td>
<td>log(exp(x) - exp(y))</td>
</tr>
<tr class="even">
<td>-log1p_exp(-x)</td>
<td>log(expit(x))</td>
</tr>
</tbody>
</table>
<p>Also study <code>bernoulli_logit</code> and <code>categorical_logit</code>.</p>
<p>To look up Stan function near-equivalents to R functions use <code>rstan::lookup('ncol')</code> for example.</p>
<p>Some answers to my coding questions appear <a href="https://discourse.mc-stan.org/t/how-to-declare-and-use-integer-matrices">here</a>, e.g.:</p>
<ul>
<li>declaring an argument as an integer matrix: <code>int[,] y</code></li>
<li>can’t use <code>max()</code> on a matrix; can temporarily (with some overhead) convert using <code>max(to_array_1d(y))</code>.</li>
<li>nummber of columns in a row vector: <code>int p = cols(X[1])</code></li>
<li>number of rows in a row vector: <code>size(X)</code></li>
</ul>
<h1 id="other-useful-links">Other Useful Links</h1>
<ul>
<li><a href="https://discourse.mc-stan.org/t/bias-in-main-effects-for-logistic-model-with-random-intercept-and-small-cluster-sizes">Logistic model with random intercept and small cluster sizes</a></li>
<li><a href="https://discourse.mc-stan.org/t/algebra-solver-has-a-side-effect-on-log-probability">Implicit parameters as with marginal structural models</a></li>
</ul>
</body>
</html>
